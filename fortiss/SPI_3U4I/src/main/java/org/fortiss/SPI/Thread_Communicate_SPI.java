package org.fortiss.SPI;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.logging.Logger;

import org.fortiss.bricks.Brick_4_602;
import org.fortiss.configuration.Setup;

import com.pi4j.io.gpio.GpioPinDigitalOutput;
import com.pi4j.io.spi.SpiDevice;


/** 
 * shall we rename it to Thread_Communicate_SPI?
 *
 */
public class Thread_Communicate_SPI extends Thread {

	private int queuesize = 2;

	//Instanz of the class which represents the spi-interface 
	//used in this class with the method spi.write() to write and read data
	private SpiDevice spi;
	//pin 6 is the slave select pin and must be set high before starting the initialization 
	private GpioPinDigitalOutput pin06;
	//Used to store the List of bricks which is generated by the Setup.class from the org.fortiss.configuration package via the Jason-file
	private ArrayList<Brick_4_602> brickList;
	//the flag is used to switch between Operational- and Debugmode. The flag is set by the user when starting the programm 
	private int outputStyle;

	//a logger instance used to check that the system works 
	Logger logger;

	//creating the LinkedBlockingQueues for the communication between the threads
	ArrayList<ArrayBlockingQueue<DataStruct>> dataQueues = null;
	DataStruct[] dsArray = null;

	//constructor 
	public Thread_Communicate_SPI(int outputStyle, Logger logger, SpiDevice spi,
			GpioPinDigitalOutput pin06, ArrayList<ArrayBlockingQueue<DataStruct>> dataQueues, DataStruct[] dsArray) {
		this.pin06 = pin06;
		this.spi = spi;
		this.outputStyle = outputStyle;
		this.logger = logger;
		this.dataQueues = dataQueues;
		this.dsArray = dsArray;		
	}

	/*
	 * Variables for running communication
	 */

	//counts the package that got transfered
	static int packageCounter = 0;
	//counts the data transfers for which the status byte of the brick was unequal one
	static int errorCounter = 0;
	//counts the how often the program was restarted because the percentage of failed communication is > 25%
	static int restartCounter =  0;

	// since the communication needs some time to run stable "gettingWarmTransfers" gets used to make sure
	// that the communication will not be restarted before at least 300 package have been send 
	static int gettingWarmTransfers = 0;

	//Enables us to stop the while loop, exit the method "communicate" and thereby restarting 
	//the whole process of initialization and communication
	static boolean running =true;


	public void run(){
		//Calling the method communicate which handles the initialization and the data transfer
		while(true){		
			//updating the setup of the bricks 
			Setup setup = initBricks();			
			communicate(setup);
			try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}


	private void communicate(Setup setup) {
		/*
		 * Starting with initialization:
		 */

		//Setting slave select to high
		pin06.high();
		try {
			//initialization of the brick including the "select next slave" routine 
			initCommunication(setup, outputStyle);
			Thread.sleep(6);
		}catch (InterruptedException | IOException e) {
			logger.warning("error do to Tread.sleep() or IOException in initilize sequence");
			e.printStackTrace();
		}

		/**
		 * Starting the actual Communication
		 */
		try{
			int[] bufferReceived = null;

			//starting endless loop for the data transfer
			while(running){

				//break between each string send to the brick chain
				Thread.sleep(5);

				int health = 0;
				for (int i = 0; i < brickList.size(); i++) {
					//break between each package of the string addressing the different bricks
					Thread.sleep(5);
					//selecting the next brick
					Brick_4_602 brick = brickList.get(i);
					//transfering the data
					bufferReceived = brick_4_602_dataTransfer(brick);
					createOutput(bufferReceived, brick, i);
					
					//System.out.println("BR"+i+" --> Buffer received: " + Arrays.toString(bufferReceived)); passt
									
					if(health==5){
						brick.setCommuCounter(bufferReceived[1]);
						//brick.adjustBrickCommunicationCounter(brick.getDataPackage().get(0));
					}
					health++;
				}
			}
		}catch (IOException | InterruptedException e) {
			logger.warning("error do to Tread.sleep() or IOException in cread/write sequence");
			e.printStackTrace();
		}
	}



	/**
	 * <strong>Method</strong> which coordinates the transfer and the storage of the data
	 * Bricks brick_4_602 = current brick from the brickList
	 * dataPackageCounter = count of every "unique" data package which got transfered
	 * outputStyle = chooses the mode of the data handling
	 */
	private int[] brick_4_602_dataTransfer(Brick_4_602 brick_4_602) throws IOException, InterruptedException {

		//Writing the header of the communication Sequence to the brick
		//Not printing the header since they only consist of [0,0,0]

		spi.write(brick_4_602.getDataHeader());

		//Writing the body of the communication Sequence to the brick and saving the answer in the array bufBody
		//System.out.println(Arrays.toString(brick_4_602.getDataPackage().get(dataPackageCounter)));
		//short[] bufBody = spi.write(brick_4_602.getDataPackage().get(dataPackageCounter));
		short[] bufBody = spi.write(brick_4_602.getDataPackage().get(0));
		int[] bufBodyInt = new int[bufBody.length];
		for (int i = 0; i < bufBody.length; i++) {
			bufBodyInt[i] = bufBody[i];
		}

		//returning the buffer containing the bricks answer to be able to check in the while loop if the resultcounter has been increased
		return bufBodyInt;
	}

	/**
	 * 
	 * @param bufBody
	 * @param brick_4_602
	 * @param slave
	 */
	private void createOutput(int[] bufBody, Brick_4_602 brick_4_602, int slave) {		
		if(bufBody[0]!=1){
			errorCounter = errorCounter+1;
			if ( (outputStyle == 1) || (errorCounter % 1 == 0) ) {
				System.out.println("Aktueller Brick = " + brick_4_602.getAddressOfSlave());
				System.out.println("Aktuelles DatenPacket = " + packageCounter );
				System.out.print("Error counter: " +  errorCounter + "  --> ");
			}
		}else {
			/**
			 * Checking if the the result is new or old
			 * old -> ignore answer and start new request
			 * new -> write result to queue  
			 */
			if(bufBody[2] > 0) {
				packageCounter++;
				switch (outputStyle) {
				/**
				 * CASE 1: for debugging, the answer is printed locally, but not send to server.
				 */
				case 1:
					System.out.println("---------Store OUTPUT: "+packageCounter+"-----------------");
					System.out.println("Real_output"+Arrays.toString(brick_4_602.getDataPackage().get(0)));
					System.out.print("BrickNR:" + slave + " OUTPUTBody "+brick_4_602.getCommandList().get(0)+" =  ");
					System.out.println(Arrays.toString(bufBody));
					break;
					
				/**
				 * CASE 2: for runtime environment
				 */					
				case 2:
					String commandString = brick_4_602.getCommandList().get(0);					
					dsArray[slave] = new DataStruct(commandString, slave, bufBody);
					
					//dataQueues.get(slave).offer(dataenum);
					//System.out.println("To queue in Output: " + Arrays.toString(dsList[slave].buffer) );
					//System.out.println("From queue: " + Arrays.toString(dataQueues.get(slave).poll().buffer) );
					
					break;
				}
			}
		}

		//Checking how many data transfers failed
		//if the percentage of failed transfers is to high the whole communication will be restarted

		//System.out.println("Errors: " + errorCounter + "  Good Values: " + packageCounter);

		if (packageCounter % 200 == 0 && packageCounter != 0){
			logger.info("-----------------Packagecounter:"+packageCounter+"-----------------");
			double errorPercentage = 100.0*errorCounter/(packageCounter+errorCounter);
			logger.warning("-----------------Errorcounter:"+errorCounter+"/"+packageCounter +"= " + errorPercentage+ "% -----------------");			
			logger.info("errorPercentage: "+ errorPercentage);
			logger.info("packageCounter: "+ packageCounter);
			logger.info("gettingWarmTransfers: "+ gettingWarmTransfers);

			if(errorPercentage >= 30 && packageCounter >= gettingWarmTransfers){
				logger.warning(errorPercentage+"% of the data transfers results in errors");
				if(errorPercentage > 50){
					restartCounter = restartCounter +1;
					logger.severe("More than 50% of the the data transfers results in errors the program will be restarted");
					logger.severe("Incrementing the restart counter by one => Restart Counter = "+ restartCounter);
					//By setting running to false the method "communicate" will exit its while loop and terminate.
					//the while loop of run{} will than make again a call to "communicate" and therefore restart the whole process
					running = false;
				}
			}
		}
	}
	/**
	 * Method which handles the initialization of the bricks as well as the "select next slave" routine 
	 * Setup: Contains all the appropriate datapackages 
	 */
	private void initCommunication(Setup setup, int outputStyle) throws InterruptedException, IOException {
		//The loop goes through all brick which are connected to the daisy chain according to the Jason-File
		for(int j = 0; j < setup.init_DataHeaderAndBody.size(); j++){
			if(outputStyle == 1){
				Thread.sleep(8);			
				//Header of the initialization sequence 
				System.out.print("INPUT_Head initBuffer  =  ");
				System.out.println(Arrays.toString(setup.init_DataHeaderAndBody.get(j)));
				//Body of the initialization sequence
				Thread.sleep(8);
				System.out.print("OUTPUT_Head initBuffer  =  ");
				System.out.println(Arrays.toString(spi.write(setup.init_DataHeaderAndBody.get(j))));

				Thread.sleep(11);
				//Header of the select  sequence 
				System.out.print("INPUT_Head selectBuffer  =  ");
				System.out.println(Arrays.toString(setup.select_Data.get(j)));
				System.out.print("OUTPUT_Head selectBuffer  =  ");
				System.out.println(Arrays.toString(spi.write(setup.select_Data.get(j))));
			}else{
				Thread.sleep(8);
				//Header of the initialization sequence 
				logger.info("INPUT_Head initBuffer  =  "+ Arrays.toString(setup.init_DataHeaderAndBody.get(j)));
				//Body of the initialization sequence 
				logger.info("OUTPUT_Head initBuffer  =  "+ Arrays.toString(spi.write(setup.init_DataHeaderAndBody.get(j))));
				Thread.sleep(11);
				//Header of the select  sequence 
				logger.info("INPUT_Head selectBuffer  =  "+ Arrays.toString(setup.select_Data.get(j)));
				logger.info("OUTPUT_Head selectBuffer  =  "+ Arrays.toString(spi.write(setup.select_Data.get(j))));		
			}
		}
	}

	/**
	 * Method to read the Setup configuration from file and initialize the Bricks.
	 * 
	 * @return Setup configuration
	 */
	private Setup initBricks() {		
		//Creating an instance of Setup.class which initializes all the data packages via the information from the Jasonfile
		Setup setup = new Setup();
		//Passing the created ArrayList containing the Bricks from setup.bricklist to brickList
		brickList = setup.bricksList;
		for (int i = 0; i < brickList.size(); i++) {
			this.dataQueues.add(new ArrayBlockingQueue<>(queuesize));
		}

		System.out.println(dataQueues.size() + " Queues established with size: " + queuesize);		
		//setting running to true for the case that the communication was restarted 
		//for the same reason setting the pins to low
		running = true;
		pin06.low();

		/*
		 * important to measure error counts and re-initialization
		 */
		gettingWarmTransfers = packageCounter + 200;
		return setup;
	}

}






